<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Matching…</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light only">
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <style>
    html, body { background:#fff; color:#111; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:2rem; }
    .bar-wrap { width:100%; max-width:640px; height:16px; background:#eee; border-radius:999px; overflow:hidden; border:1px solid #ddd; }
    .bar { height:100%; width:0%; background:#0a7a0a; transition: width .18s ease; }
    .row { display:flex; align-items:center; gap:1rem; margin-top:.75rem; }
    .muted { color:#666; }
    .error { color:#b00020; margin-top: 1rem; }
  </style>
</head>
<body data-job-id="{{ job_id }}" data-total="{{ total|default:0 }}">
  <a href="{% url 'landing' %}">← Home</a>
  <h1>Matching your playlist…</h1>

  <div class="bar-wrap" aria-hidden="true"><div id="bar" class="bar"></div></div>
  <div class="row">
    <div id="pct"><strong>0%</strong></div>
    <div class="muted" id="counts">0 / {{ total|default:"?" }}</div>
  </div>
  <p class="muted">Please keep this tab open while we match tracks.</p>
  <div id="err" class="error" role="alert" style="display:none;"></div>

  <script>
    function getCookie(name) {
      const m = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
      return m ? decodeURIComponent(m.pop()) : '';
    }

    (function () {
      const jobId = document.body.dataset.jobId || '';
      let totalCount = Number(document.body.dataset.total || '0') || 0;

      const bar = document.getElementById('bar');
      const pct = document.getElementById('pct');
      const counts = document.getElementById('counts');
      const err = document.getElementById('err');

      // Local notion of "done" so we can animate per-song
      let localDone = 0;
      const BATCH_SIZE = 10;
      const MAX_POLLS = 2000;  // safety
      let polls = 0;

      function paint(done, total) {
        const t = total || totalCount || 1;
        const p = Math.floor((done / t) * 100);
        bar.style.width = p + '%';
        pct.innerHTML = `<strong>${p}%</strong>`;
        counts.textContent = `${done} / ${t}`;
      }

      function animateSongs(n, total, after) {
        if (n <= 0) { after(); return; }
        localDone += 1;
        paint(localDone, total);
        // small delay per song for smoothness
        setTimeout(() => animateSongs(n - 1, total, after), 90);
      }

      async function step() {
        if (++polls > MAX_POLLS) {
          throw new Error('Too many polling attempts — aborting.');
        }
        const url = `/match/run/${encodeURIComponent(jobId)}?batch=${BATCH_SIZE}`;
        const resp = await fetch(url, {
          method: 'POST',
          credentials: 'same-origin',
          headers: { 'X-CSRFToken': getCookie('csrftoken') }
        });

        if (!resp.ok) {
          const txt = await resp.text();
          throw new Error(txt || ('HTTP ' + resp.status));
        }

        const data = await resp.json();
        const serverDone = Number(data.done || 0);
        const processed = Number(data.processed || 0);

        // Server's total is authoritative once seen
        if ((data.total || 0) > 0) totalCount = Number(data.total);
        const total = totalCount > 0 ? totalCount : (Number(data.total || 0) || 1);

        // Ensure localDone catches up if needed (e.g., first response)
        if (localDone < serverDone - processed) {
          localDone = serverDone - processed;
          paint(localDone, total);
        }

        // Animate one tick per processed song, then continue polling
        animateSongs(processed, total, () => {
          if (data.status === 'done' && total > 0 && serverDone >= total) {
            window.location.href = `/match/results/${encodeURIComponent(jobId)}?created=0`;
            return;
          }
          // Slight pause so the browser paints between polls
          setTimeout(step, 120);
        });
      }

      if (!jobId) {
        err.textContent = 'Missing job id. Please start the match again.';
        err.style.display = 'block';
        return;
      }

      // Initialize display
      paint(0, totalCount);

      step().catch((e) => {
        console.error(e);
        err.textContent = 'Matching failed: ' + (e.message || 'Unknown error');
        err.style.display = 'block';
      });
    })();
  </script>
</body>
</html>
